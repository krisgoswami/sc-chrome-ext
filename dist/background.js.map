{"version":3,"file":"background.js","mappings":";;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AE3QA;AACA;AACA;AACA;AACA","sources":["webpack://sc-chrome-ext/./src/background.ts","webpack://sc-chrome-ext/webpack/before-startup","webpack://sc-chrome-ext/webpack/startup","webpack://sc-chrome-ext/webpack/after-startup"],"sourcesContent":["\"use strict\";\n// Background script with dual-mode capture support\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nlet state = {\n    isCapturing: false,\n    originalTabId: null,\n    tabsToCapture: [],\n    currentIndex: 0,\n    successCount: 0,\n    failureCount: 0,\n    skippedCount: 0,\n    isCancelled: false,\n    mode: 'page'\n};\n// Utilities\nfunction getTimestamp() {\n    const now = new Date();\n    const pad = (n) => n.toString().padStart(2, '0');\n    return `${now.getFullYear()}-${pad(now.getMonth() + 1)}-${pad(now.getDate())}_${pad(now.getHours())}-${pad(now.getMinutes())}-${pad(now.getSeconds())}`;\n}\nfunction showNotification(title, message, type = 'basic') {\n    chrome.notifications.create({\n        type: type,\n        iconUrl: 'icons/icon.png',\n        title: title,\n        message: message\n    });\n}\nfunction isRestrictedUrl(url) {\n    if (!url)\n        return true;\n    return url.startsWith('chrome://') ||\n        url.startsWith('edge://') ||\n        url.startsWith('about:') ||\n        url.startsWith('chrome-extension://');\n}\nfunction setupOffscreenDocument(path) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const existingContexts = yield chrome.runtime.getContexts({\n            contextTypes: [chrome.runtime.ContextType.OFFSCREEN_DOCUMENT]\n        });\n        if (existingContexts.length > 0) {\n            return;\n        }\n        yield chrome.offscreen.createDocument({\n            url: path,\n            reasons: [chrome.offscreen.Reason.DISPLAY_MEDIA],\n            justification: 'Recording window for screenshot sequence'\n        });\n    });\n}\nfunction captureNext() {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (state.isCancelled) {\n            yield finishCapture(true);\n            return;\n        }\n        if (state.currentIndex >= state.tabsToCapture.length) {\n            yield finishCapture(false);\n            return;\n        }\n        const tab = state.tabsToCapture[state.currentIndex];\n        if (!tab.id) {\n            state.failureCount++;\n            state.currentIndex++;\n            captureNext();\n            return;\n        }\n        chrome.action.setBadgeText({ text: `${state.currentIndex + 1}/${state.tabsToCapture.length}` });\n        if (isRestrictedUrl(tab.url)) {\n            console.warn(`Skipping restricted URL: ${tab.url}`);\n            state.skippedCount++;\n            state.currentIndex++;\n            captureNext();\n            return;\n        }\n        // Activate tab\n        try {\n            yield chrome.tabs.update(tab.id, { active: true });\n        }\n        catch (e) {\n            console.error(`Failed to activate tab ${tab.id}:`, e);\n            state.failureCount++;\n            state.currentIndex++;\n            captureNext();\n            return;\n        }\n        const wait = (ms) => new Promise(resolve => setTimeout(resolve, ms));\n        // Different wait times for different modes\n        const waitTime = state.mode === 'window' ? 1200 : 800;\n        yield wait(waitTime);\n        try {\n            let dataUrl;\n            if (state.mode === 'window') {\n                // Window mode: use offscreen capture\n                const response = yield chrome.runtime.sendMessage({ type: 'CAPTURE_FRAME' });\n                if (!response || !response.dataUrl) {\n                    throw new Error((response === null || response === void 0 ? void 0 : response.error) || \"Failed to capture frame from offscreen\");\n                }\n                dataUrl = response.dataUrl;\n            }\n            else {\n                // Page mode: use captureVisibleTab with retry\n                let attempts = 0;\n                while (!dataUrl && attempts < 3) {\n                    try {\n                        dataUrl = yield chrome.tabs.captureVisibleTab(tab.windowId, { format: 'png' });\n                    }\n                    catch (captureErr) {\n                        console.warn(`Capture attempt ${attempts + 1} failed for tab ${tab.id}:`, captureErr);\n                        attempts++;\n                        if (attempts < 3) {\n                            yield wait(500);\n                        }\n                    }\n                }\n                if (!dataUrl) {\n                    throw new Error(\"Failed to capture tab after 3 attempts\");\n                }\n            }\n            const folderName = `tab-screenshots/${state.timestamp}`;\n            const fileName = `${folderName}/tab-${(state.currentIndex + 1).toString().padStart(2, '0')}.png`;\n            yield chrome.downloads.download({\n                url: dataUrl,\n                filename: fileName,\n                saveAs: false\n            });\n            state.successCount++;\n        }\n        catch (e) {\n            console.error(`Failed to process tab ${tab.id}:`, e);\n            state.failureCount++;\n        }\n        state.currentIndex++;\n        captureNext();\n    });\n}\nfunction startCapture() {\n    return __awaiter(this, arguments, void 0, function* (mode = 'page') {\n        if (state.isCapturing) {\n            showNotification('Already Capturing', 'A capture session is already in progress.');\n            return;\n        }\n        const [currentTab] = yield chrome.tabs.query({ active: true, currentWindow: true });\n        if (!currentTab || currentTab.index === undefined) {\n            showNotification('Error', 'Could not identify the current tab.');\n            return;\n        }\n        const allTabs = yield chrome.tabs.query({ currentWindow: true });\n        const sortedTabs = allTabs.sort((a, b) => a.index - b.index);\n        const targetTabs = sortedTabs.filter(t => t.index >= currentTab.index);\n        if (targetTabs.length === 0) {\n            showNotification('No Tabs', 'No tabs found to capture.');\n            return;\n        }\n        const capturableTabs = targetTabs.filter(t => !isRestrictedUrl(t.url));\n        if (capturableTabs.length === 0) {\n            showNotification('No Capturable Tabs', 'All tabs are restricted URLs and cannot be captured.');\n            return;\n        }\n        state = {\n            isCapturing: true,\n            originalTabId: currentTab.id || null,\n            tabsToCapture: targetTabs,\n            currentIndex: 0,\n            successCount: 0,\n            failureCount: 0,\n            skippedCount: 0,\n            isCancelled: false,\n            mode: mode\n        };\n        // @ts-ignore\n        state.timestamp = getTimestamp();\n        chrome.action.setBadgeBackgroundColor({ color: '#4285f4' });\n        try {\n            if (mode === 'window') {\n                // Window mode: setup offscreen\n                yield setupOffscreenDocument('offscreen.html');\n                const initResponse = yield chrome.runtime.sendMessage({ type: 'INIT_DISPLAY_CAPTURE' });\n                if (!initResponse || !initResponse.success) {\n                    throw new Error((initResponse === null || initResponse === void 0 ? void 0 : initResponse.error) || 'Failed to initialize display capture');\n                }\n                yield new Promise(r => setTimeout(r, 800));\n            }\n            captureNext();\n        }\n        catch (e) {\n            console.error(\"Failed to setup capture\", e);\n            showNotification('Error', mode === 'window'\n                ? 'Failed to initialize screen capture. Make sure you selected a window to share.'\n                : 'Failed to start capture. Please try again.');\n            state.isCapturing = false;\n            chrome.action.setBadgeText({ text: '' });\n        }\n    });\n}\nfunction cancelCapture() {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (!state.isCapturing)\n            return;\n        state.isCancelled = true;\n        showNotification('Capture Cancelled', 'Screenshot capture has been cancelled.');\n    });\n}\nfunction finishCapture(cancelled) {\n    return __awaiter(this, void 0, void 0, function* () {\n        state.isCapturing = false;\n        chrome.action.setBadgeText({ text: '' });\n        // Stop and close offscreen if in window mode\n        if (state.mode === 'window') {\n            try {\n                yield chrome.runtime.sendMessage({ type: 'STOP_CAPTURE' });\n                yield chrome.offscreen.closeDocument();\n            }\n            catch (e) {\n                // Ignore if already closed\n            }\n        }\n        // Restore original tab\n        if (state.originalTabId) {\n            try {\n                yield chrome.tabs.update(state.originalTabId, { active: true });\n            }\n            catch (e) {\n                console.error(\"Failed to restore tab\", e);\n            }\n        }\n        if (!cancelled) {\n            let message = `✓ ${state.successCount} captured`;\n            if (state.skippedCount > 0) {\n                message += ` | ⏭ ${state.skippedCount} skipped`;\n            }\n            if (state.failureCount > 0) {\n                message += ` | ✗ ${state.failureCount} failed`;\n            }\n            showNotification('Capture Complete', message);\n        }\n    });\n}\n// Listeners\nchrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\n    if (message.type === 'START_CAPTURE') {\n        startCapture(message.mode || 'page');\n        sendResponse({ success: true });\n    }\n    else if (message.type === 'CANCEL_CAPTURE') {\n        cancelCapture();\n        sendResponse({ success: true });\n    }\n    else if (message.type === 'GET_STATUS') {\n        sendResponse({\n            isCapturing: state.isCapturing,\n            progress: state.isCapturing ? `${state.currentIndex}/${state.tabsToCapture.length}` : null,\n            successCount: state.successCount,\n            failureCount: state.failureCount,\n            skippedCount: state.skippedCount\n        });\n    }\n    return true;\n});\n","","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = {};\n__webpack_modules__[\"./src/background.ts\"].call(__webpack_exports__);\n",""],"names":[],"ignoreList":[],"sourceRoot":""}