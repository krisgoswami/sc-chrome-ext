{"version":3,"file":"background.js","mappings":";;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AE9NA;AACA;AACA;AACA;AACA","sources":["webpack://sc-chrome-ext/./src/background.ts","webpack://sc-chrome-ext/webpack/before-startup","webpack://sc-chrome-ext/webpack/startup","webpack://sc-chrome-ext/webpack/after-startup"],"sourcesContent":["\"use strict\";\n// Background script with enhanced error handling and notifications\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nlet state = {\n    isCapturing: false,\n    originalTabId: null,\n    tabsToCapture: [],\n    currentIndex: 0,\n    successCount: 0,\n    failureCount: 0,\n    skippedCount: 0,\n    isCancelled: false\n};\n// Utilities\nfunction getTimestamp() {\n    const now = new Date();\n    const pad = (n) => n.toString().padStart(2, '0');\n    return `${now.getFullYear()}-${pad(now.getMonth() + 1)}-${pad(now.getDate())}_${pad(now.getHours())}-${pad(now.getMinutes())}-${pad(now.getSeconds())}`;\n}\nfunction showNotification(title, message, type = 'basic') {\n    chrome.notifications.create({\n        type: type,\n        iconUrl: 'icons/icon.png',\n        title: title,\n        message: message\n    });\n}\nfunction isRestrictedUrl(url) {\n    if (!url)\n        return true;\n    return url.startsWith('chrome://') ||\n        url.startsWith('edge://') ||\n        url.startsWith('about:') ||\n        url.startsWith('chrome-extension://');\n}\nfunction captureNext() {\n    return __awaiter(this, void 0, void 0, function* () {\n        // Check for cancellation\n        if (state.isCancelled) {\n            yield finishCapture(true);\n            return;\n        }\n        if (state.currentIndex >= state.tabsToCapture.length) {\n            // Done\n            yield finishCapture(false);\n            return;\n        }\n        const tab = state.tabsToCapture[state.currentIndex];\n        if (!tab.id) {\n            state.failureCount++;\n            state.currentIndex++;\n            captureNext();\n            return;\n        }\n        // Update Badge\n        chrome.action.setBadgeText({ text: `${state.currentIndex + 1}/${state.tabsToCapture.length}` });\n        // Check for restricted URLs\n        if (isRestrictedUrl(tab.url)) {\n            console.warn(`Skipping restricted URL: ${tab.url}`);\n            state.skippedCount++;\n            state.currentIndex++;\n            captureNext();\n            return;\n        }\n        // Activate tab\n        try {\n            const updateResult = yield chrome.tabs.update(tab.id, { active: true });\n            if (updateResult && updateResult.status === 'loading') {\n                // Tab is loading\n            }\n        }\n        catch (e) {\n            console.error(`Failed to activate tab ${tab.id}:`, e);\n            state.failureCount++;\n            state.currentIndex++;\n            captureNext();\n            return;\n        }\n        // Helper wait function\n        const wait = (ms) => new Promise(resolve => setTimeout(resolve, ms));\n        // Wait for render\n        yield wait(800);\n        try {\n            // Retry logic for capture\n            let dataUrl;\n            let attempts = 0;\n            while (!dataUrl && attempts < 3) {\n                try {\n                    dataUrl = yield chrome.tabs.captureVisibleTab(tab.windowId, { format: 'png' });\n                }\n                catch (captureErr) {\n                    console.warn(`Capture attempt ${attempts + 1} failed for tab ${tab.id}:`, captureErr);\n                    attempts++;\n                    if (attempts < 3) {\n                        yield wait(500);\n                    }\n                }\n            }\n            if (!dataUrl) {\n                throw new Error(\"Failed to capture tab after 3 attempts\");\n            }\n            const folderName = `tab-screenshots/${state.timestamp}`;\n            const fileName = `${folderName}/tab-${(state.currentIndex + 1).toString().padStart(2, '0')}.png`;\n            yield chrome.downloads.download({\n                url: dataUrl,\n                filename: fileName,\n                saveAs: false\n            });\n            state.successCount++;\n        }\n        catch (e) {\n            console.error(`Failed to process tab ${tab.id}:`, e);\n            state.failureCount++;\n        }\n        state.currentIndex++;\n        captureNext();\n    });\n}\nfunction startCapture() {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (state.isCapturing) {\n            showNotification('Already Capturing', 'A capture session is already in progress.');\n            return;\n        }\n        const [currentTab] = yield chrome.tabs.query({ active: true, currentWindow: true });\n        if (!currentTab || currentTab.index === undefined) {\n            showNotification('Error', 'Could not identify the current tab.');\n            return;\n        }\n        const allTabs = yield chrome.tabs.query({ currentWindow: true });\n        const sortedTabs = allTabs.sort((a, b) => a.index - b.index);\n        const targetTabs = sortedTabs.filter(t => t.index >= currentTab.index);\n        if (targetTabs.length === 0) {\n            showNotification('No Tabs', 'No tabs found to capture.');\n            return;\n        }\n        // Filter out restricted URLs for initial count\n        const capturableTabs = targetTabs.filter(t => !isRestrictedUrl(t.url));\n        if (capturableTabs.length === 0) {\n            showNotification('No Capturable Tabs', 'All tabs are restricted URLs (chrome://, etc.) and cannot be captured.');\n            return;\n        }\n        // Initialize state\n        state = {\n            isCapturing: true,\n            originalTabId: currentTab.id || null,\n            tabsToCapture: targetTabs, // Include all, we'll skip restricted ones\n            currentIndex: 0,\n            successCount: 0,\n            failureCount: 0,\n            skippedCount: 0,\n            isCancelled: false\n        };\n        // @ts-ignore\n        state.timestamp = getTimestamp();\n        chrome.action.setBadgeBackgroundColor({ color: '#4285f4' });\n        captureNext();\n    });\n}\nfunction cancelCapture() {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (!state.isCapturing)\n            return;\n        state.isCancelled = true;\n        showNotification('Capture Cancelled', 'Screenshot capture has been cancelled.');\n    });\n}\nfunction finishCapture(cancelled) {\n    return __awaiter(this, void 0, void 0, function* () {\n        state.isCapturing = false;\n        chrome.action.setBadgeText({ text: '' });\n        // Restore original tab\n        if (state.originalTabId) {\n            try {\n                yield chrome.tabs.update(state.originalTabId, { active: true });\n            }\n            catch (e) {\n                console.error(\"Failed to restore tab\", e);\n            }\n        }\n        // Show completion notification\n        if (!cancelled) {\n            const total = state.successCount + state.failureCount + state.skippedCount;\n            let message = `✓ ${state.successCount} captured`;\n            if (state.skippedCount > 0) {\n                message += ` | ⏭ ${state.skippedCount} skipped`;\n            }\n            if (state.failureCount > 0) {\n                message += ` | ✗ ${state.failureCount} failed`;\n            }\n            showNotification('Capture Complete', message);\n        }\n    });\n}\n// Listeners\nchrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\n    if (message.type === 'START_CAPTURE') {\n        startCapture();\n        sendResponse({ success: true });\n    }\n    else if (message.type === 'CANCEL_CAPTURE') {\n        cancelCapture();\n        sendResponse({ success: true });\n    }\n    else if (message.type === 'GET_STATUS') {\n        sendResponse({\n            isCapturing: state.isCapturing,\n            progress: state.isCapturing ? `${state.currentIndex}/${state.tabsToCapture.length}` : null,\n            successCount: state.successCount,\n            failureCount: state.failureCount,\n            skippedCount: state.skippedCount\n        });\n    }\n    return true;\n});\n","","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = {};\n__webpack_modules__[\"./src/background.ts\"].call(__webpack_exports__);\n",""],"names":[],"ignoreList":[],"sourceRoot":""}