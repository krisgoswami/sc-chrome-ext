{"version":3,"file":"offscreen.js","mappings":";;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AEtFA;AACA;AACA;AACA;AACA","sources":["webpack://sc-chrome-ext/./src/offscreen/offscreen.ts","webpack://sc-chrome-ext/webpack/before-startup","webpack://sc-chrome-ext/webpack/startup","webpack://sc-chrome-ext/webpack/after-startup"],"sourcesContent":["\"use strict\";\n// Offscreen document for desktop capture using getDisplayMedia\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nlet video = null;\nlet canvas = null;\nlet stream = null;\nfunction startDisplayCapture() {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (stream) {\n            stream.getTracks().forEach(track => track.stop());\n        }\n        try {\n            // Use getDisplayMedia directly - this is the correct approach for offscreen documents\n            // preferCurrentTab: false helps avoid tab selection\n            stream = yield navigator.mediaDevices.getDisplayMedia({\n                video: {\n                    displaySurface: 'window', // Prefer window over tab\n                    width: { ideal: 1920 },\n                    height: { ideal: 1080 }\n                },\n                preferCurrentTab: false // Don't default to current tab\n            }); // Cast needed for preferCurrentTab\n            if (!video)\n                video = document.getElementById('stream');\n            video.srcObject = stream;\n            yield video.play();\n            console.log('Display capture started successfully');\n            // Wait a bit for video to be ready\n            yield new Promise(resolve => setTimeout(resolve, 500));\n        }\n        catch (e) {\n            console.error(\"Failed to start display capture\", e);\n            throw e;\n        }\n    });\n}\nfunction captureFrame() {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (!video || !stream) {\n            console.error('Video or stream not ready');\n            return null;\n        }\n        // Check if video has valid dimensions\n        if (video.videoWidth === 0 || video.videoHeight === 0) {\n            console.error('Video not ready yet');\n            return null;\n        }\n        if (!canvas)\n            canvas = document.getElementById('capture');\n        canvas.width = video.videoWidth;\n        canvas.height = video.videoHeight;\n        const ctx = canvas.getContext('2d');\n        if (!ctx)\n            return null;\n        ctx.drawImage(video, 0, 0);\n        return canvas.toDataURL('image/png');\n    });\n}\nchrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\n    if (message.type === 'INIT_DISPLAY_CAPTURE') {\n        startDisplayCapture()\n            .then(() => sendResponse({ success: true }))\n            .catch(error => sendResponse({ success: false, error: error.message }));\n        return true; // Keep channel open for async response\n    }\n    else if (message.type === 'CAPTURE_FRAME') {\n        captureFrame()\n            .then(dataUrl => sendResponse({ dataUrl }))\n            .catch(error => sendResponse({ dataUrl: null, error: error.message }));\n        return true;\n    }\n    else if (message.type === 'STOP_CAPTURE') {\n        if (stream) {\n            stream.getTracks().forEach(track => track.stop());\n            stream = null;\n        }\n        sendResponse({ success: true });\n    }\n});\n","","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = {};\n__webpack_modules__[\"./src/offscreen/offscreen.ts\"].call(__webpack_exports__);\n",""],"names":[],"ignoreList":[],"sourceRoot":""}